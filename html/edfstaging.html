<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type='text/css' href="../css/edfbase.css"></style>
<link rel="stylesheet" type='text/css' href="../css/edfdataviewer.css"></style>
<link rel="stylesheet" type='text/css' href="../css/edfstaging.css"></style>
<!-- Load scripts locally -->
<script src="../js/plotly-latest.min.js"></script>
<!-- <script src="../js/edf&#45;0.1.0.min.js"></script> -->
<script src="../js/edf.js"></script>
<script src="../js/tfjs-0.11.2-mod.js"></script>
<script src="../js/papaparse.min.js"></script>
<!-- Load scripts from CDNs -->
<script type="text/javascript">
  // if (typeof edfjs == 'undefined') {
  //   document.write(unescape("%3Cscript src='https://cdn.rawgit.com/jusjusjus/edfjs/b1696d8c/dist/releases/edf-0.1.0.min.js' type='text/javascript'%3E%3C/script%3E"));
  // }
  // if (typeof Plotly == 'undefined') {
  //   document.write(unescape("%3Cscript src='https://cdn.plot.ly/plotly&#45;latest.min.js' type='text/javascript'%3E%3C/script%3E"));
  // }
</script>
<script src="../js/fili.min.js"></script>
<script src="../js/util.js"></script>
<script src="../js/filtered_edf.js" type="module"></script>
<script src="../js/plotting_area.js"></script>
<script src="../js/hypnogram.js"></script>
<script src="../js/slider.js"></script>
<script src="../js/sleep_staging_model.js"></script>
<script src="../js/annotations.js"></script>
<script>
	var edffile = null;
	var figure = null;
	var hypnogram = null;
	var slider = null;
	var model = null;
  var dataloader = null;
	var annotations = null;

	async function load_selected_annots() {
		var files = document.getElementById('scoreSelector').files;
		annotations = await Annotations().load(files[0]);
	}

	async function predict_current_stage() {
		if (dataloader === null) build_dataloader();

		const T = await dataloader.get(slider.value);
		const Y = await model.predict(T);
		var V = Y.buffer().values;

		var txt = "Prob = ("+toPercentStr(V)+")";
		document.getElementById('prediction').innerHTML = txt;

		T.dispose()
		Y.dispose()
	}

	// async function predictOnBatch(batch) {
	// 	document.getElementById("prediction").innerHTML = "Example "+batch.length;
	// }
  //
	// async function asyncPredict() {
	// 	build_dataloader();
	// 	const batch_size = 64;
	// 	const num_classes = 5;
	// 	var batch = [];
	// 	annotations = Annotations(model.config.input.duration);
	// 	show_hypnogram();
	// 	var ii = 0;
	// 	async function build_batch_and_predict() {
	// 		var batch = [];
	// 		console.log('ii', ii);
	// 		for (ii; ii<dataloader.length; ii++) {
	// 			var example = await dataloader.get(ii);
	// 			batch.push(example);
	// 			if(batch.length == batch_size) {
	// 				predictOnBatch(batch);
	// 				ii = i;
	// 				window.requestAnimationFrame(build_batch_and_predict);
	// 				break
	// 			}
	// 		}
	// 	}
	// 	window.requestAnimationFrame(build_batch_and_predict);
	// }

	async function predict() {
		build_dataloader();
		const batch_size = 64;
		const num_classes = 5;
		var batch = [];
		annotations = Annotations(model.config.input.duration);
		show_hypnogram();
		for (var ii=0; ii<dataloader.length; ii++) {
			batch.push(await dataloader.get(ii));
			if (batch_size == batch.length) {
				const result = tf.tidy( () => {
					const T = tf.concat(batch, axis=0);
					return model.predict(T);
				});
				var arr = result.buffer().values;
				var probs = [];
				for (var e=0; e<arr.length; e+=num_classes) {
					probs.push(arr.slice(e, e+num_classes));
				}
				annotations.stream_probs(probs);
				hypnogram.redraw();
				result.dispose();
				for(var b in batch) {
					batch[b].dispose();
				}
				batch = [];
			}
			document.getElementById("prediction").innerHTML = "Example "+ii;
		}
		if (batch.length > 0) {
			const result = tf.tidy( () => {
				const T = tf.concat(batch, axis=0);
				return model.predict(T);
			});
			var final_batch_size = result.shape[0];
			var arr = result.buffer().values;
			var probs = [];
			for (var e=0; e<arr.length; e+=num_classes) {
				probs.push(arr.slice(e, e+num_classes));
			}
			annotations.stream_probs(probs);
			hypnogram.redraw();
			result.dispose();
			for(var b in batch) {
				batch[b].dispose();
			}
			batch = [];
		}
	}

	async function load_model(num_layers=8) {
		model = Model();
		await model.load_model(num_layers);
    edffile.channel_by_label['EEG1'] = edffile.channel_by_label['EEG C3-A2'];
    edffile.channel_by_label['EEG2'] = edffile.channel_by_label['EEG C4-A1'];
    edffile.channel_by_label['EOG1'] = edffile.channel_by_label['EOG Left'];
    edffile.channel_by_label['EOG2'] = edffile.channel_by_label['EOG Right'];
    edffile.channel_by_label['EMG'] = edffile.channel_by_label['EMG Chin'];
		refresh_channelselection();
	}

  function build_dataloader() {
		edffile.set_model(model);
    dataloader = edffile.dataloader(model);
  }

	async function load_selected_file () {
		var files = document.getElementById('fileSelector').files;
    edffile = await FilteredEDF().from_file(files[0], header_only=false);
		figure = PlottingArea("figure", edffile, 30.0);
		refresh_navbar();
		slider = Slider("slider", [figure], 30.0).build();
		if (hypnogram !== null) {
			slider.register(hypnogram);
		}
		if (model === null) {
			load_model();
		}
	}

	function show_hypnogram() {
		if (hypnogram !== null && slider !== null) {
			slider.remove(hypnogram);
		}
		hypnogram = Hypnogram("hypnogram", annotations);
		hypnogram.create_new_plot();
		if (slider !== null) {
			slider.register(hypnogram);
		}
	}

	function clear_filecache () {
    figure.del(); delete figure; figure = null;
		slider.del(); delete slider; slider = null;
		delete edffile; edffile = null;
		refresh_navbar();
		document.getElementById('fileSelector').value = "";
	}

	function refresh_navbar() {
    var nav = document.getElementById("nav");
    var txt = "";
    if (figure != null) {
			var channels = figure.channels();
      for (var c in figure.channels()) {
        var C = channels[c];
        txt += "<li";
        if (C.selected) {
          txt += " class='selected'";
        } else {
          txt += " class='unselected'";
        }
        txt += " onclick='figure.switch_selection("+c+", refresh_navbar)'>"+C.label+"</li>";
      }
      txt += "<li class='clear' onclick='clear_filecache()'>Clear</li>";
    }
    nav.innerHTML = txt;
	}

	async function refresh_channelselection() {
		var txt = "";
		if (model != null && edffile != null && edffile.channel_by_label != null) {
      await model.config;
			for (i in model.config.input.channels) {
				txt += "<div class='dropdown tooltip'>";
				txt += "<span class='tooltiptext'>Select Input Channels for Automatic Sleep Staging</span>";
				var input_channel = model.config.input.channels[i];
				txt += "<button onclick='toggleDropdown(\""+input_channel+"\")' class='dropbtn'>";
				txt += input_channel;
				if (input_channel in edffile.channel_by_label) txt += " ("+edffile.channel_by_label[input_channel].label+")";
				txt += "</button>";
				txt += "<div id='"+input_channel+"' class='dropdown-content'>";
				txt += "<ul>";
				for (var c in edffile.channels) {
					target_channel = edffile.channels[c].label;
					txt += "<li onclick='channelSelected(\""+input_channel+"\", \""+target_channel+"\")'>"+target_channel+"</li>";
				}
				txt += "</ul>";
				txt += "</div>";
				txt += "</div>";
      }
			txt += "<button onclick='predict()' class='dropbtn exec'>Predict All Stages</button>";
			// txt += "<button onclick='asyncPredict()' class='dropbtn exec'>Predict All Stages</button>";
			// txt += "<button onclick='predict_current_stage()' class='dropbtn exec'>Predict Current Stage</button>";
    }
    document.getElementById("channelSelection").innerHTML = txt;
	}

	function channelSelected (input_channel, target_channel) {
    edffile.channel_by_label[input_channel] = edffile.channel_by_label[target_channel];
		refresh_channelselection();
	}

	function toggleDropdown (input_channel) {
		document.getElementById(input_channel).classList.toggle("show");
	}

	async function setup(evt) {
		var fileSelector = document.getElementById('fileSelector');
		var scoreSelector = document.getElementById('scoreSelector');
		if (fileSelector.value != "") {
      await load_selected_file();
		}
		if (scoreSelector.value != "") {
			await load_selected_annots();
			show_hypnogram();
		}
	}

	function setTimeoutAsync(callback, msec) { 
		return new Promise(resolve => {
			setTimeout(() => {resolve(callback());}, msec);
		});
	}

	function assert(condition, msg) {
		if(!condition) {
			console.error("Error: "+msg);
			throw msg;
		}
	}

</script>
</head>
<body onload="setup()">

<div class="container">

<header>
	<h3>EDF Staging Controller (BETA Version)</h3>
	<hr>
  <div style="text-align:right">
    <label for="fileSelector">EDF-file</label>
    <input type="file" id="fileSelector" onchange="load_selected_file()" accept=".edf"/>
  </div>
  <div style="text-align:right">
    <label for="scoreSelector">Score file</label>
    <input type="file" id="scoreSelector" onchange="load_selected_annots()" accept=".csv,.json"/>
  </div>
</header>

<div id="nav"></div>

<div id="channelSelection"></div>

<article>
<div class="figure" id="figure"></div>
<div class="figure" id="hypnogram"></div>
<div id="slider"></div>
<div id="prediction"></div>
</article>

<footer>Powered by <a href="https://plot.ly">plotly</a><br>
	Copyright &copy; <a href="https://github.com/jusjusjus">jusjusjus</a></footer>

</div>

</body>
</html>

